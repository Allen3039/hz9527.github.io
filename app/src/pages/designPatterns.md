# 重谈设计模式

> 如果问我进入 js 世界对我影响最大的是什么，我一定会说设计模式。
> 第一次看设计模式应该是 2016 年 9 月左右（JavaScript设计模式与开发实践-曾探）

## 前言

> 设计模式的定义是:在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。  
> 设计模式一定程度增加了代码的复杂性，但毫无疑问它同样增加了代码的可维护性，或者说在一定区间里它会增加复杂度，但超过这个区间它的威力才能显现  
> 设计模式是手段而不是目的  
> Peter Norvig 曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。

## 目录

-   [单例模式](#单例模式)

-   [策略模式](#策略模式)

-   [代理模式](#代理模式)

-   [迭代器模式](#迭代器模式)

-   [发布订阅模式](#发布订阅模式)

-   [命令模式](#命令模式)

-   [组合模式](#组合模式)

-   [模版方法模式](#模版方法模式)

-   [享元模式](#享元模式)

-   [责任链模式](#责任链模式)

-   [终结者模式](#终结者模式)

-   [装饰者模式](#装饰者模式)

-   [状态模式](#状态模式)

-   [适配器模式](#适配器模式)

-   [设计原则&编程技巧](#设计原则&编程技巧)
    - [单一职责原则(Single Responsibility Principle)](#单一职责原则SRP)
    - [里氏替换原则](#里氏替换原则LSP)
    - [依赖倒置原则DIP(Dependence Inversion Principle)](#依赖倒置原则DIP)
    - [接口隔离原则ISP(Interface Segregation Principle)](#接口隔离原则ISP)
    - [最少知识原则（迪米特原则）](#最少知识原则)
    - [开放封闭原则](#开放封闭原则)

-   [接口和面向接口编程](#接口和面向接口编程)

1. OOP 继承、封装、多态、聚合

## 单例模式

> 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式的使用场景十分多，从逻辑上来看有不可重复的数据，比如 全局缓存对象。从 UI 交互角度来看适用场景就更多了，比如 全局 toast 等等

### 基本实现

## 策略模式
## 代理模式
## 迭代器模式
## 发布订阅模式
## 命令模式
## 组合模式
## 模版方法模式
## 享元模式
## 责任链模式
## 终结者模式
## 装饰者模式
## 状态模式
## 适配器模式

## 设计原则&编程技巧

> 面向对象编程通过封装不确定因素来使代码能被人理解;函数式编程通过尽量减少不确定因素来使代码能被人理解.
> 没有最好的设计，只有最适合的设计，不同的场景这些原则划分的方式、定义的方式也不同，这也是为什么很容易出现过度设计，代码拆得太分散的原因。

### 单一职责原则SRP

> 不要存在多于一个导致类变更的原因。简单点说，一个类，最好只负责一件事，只有一个引起它变化的原因。
> 具体来说，当出现不确定因素时，我们尽量更改一处就可以了，因为根据单一职责，每个类尽量封装一处不确定因素

**问题场景**

- 类做了太多不该它管的事（正常人基本能避免）
- 职责扩散导致的问题，即由于不确定因素变更、增多使得内部耦合变得严重

> 这个在我们编码时经常遇到，虽然我们都知道单一指责，听着也很简单。基本能遵守第一类场景，但不一定能很好遵守第二类场景。
> 造成的原因是 随着需求的变动，发现一个方法内依赖了多个变化 职责（方法）间有耦合。

举个例子：
页面上有一个搜索框，然后有一个搜索和重置按钮。正常逻辑是点击搜索获取一下输入框的内容然后执行搜索，点击重置是清空输入框然后执行搜索

```js
class InputComponent {
  input(value) {
    this.search = value
  }
  search() {
    get(this.search).then(res => render(res))
  }
  reset() {
    this.search = null
    this.search()
  }
}
```

问题在于如果后续有多个搜索框呢？那么 reset 其实就和 input 耦合了，所以划分职责有问题。可以将 search 处理单独分出来

另一个常见的场景是函数入参的问题

```js
function search(page, type) {
  // ...
}
// 前置条件
function search(query) {
  return get(query)
}
function price(p) {
  return (page, type) => {
    const query = {page, type, price: p}
    return search(query)
  }
}
price(123)(10, '1') // 调用与原来一致

// 后置条件

```

**解决方案**  

尽量让一个类、函数完成的工作只被一个因素改变，减少对外部依赖。单一职责很难的原因也是因为职责扩散问题，随着需求变动，可变因素增加。
对于单一职责，没有最好的设计，只有最适合的设计

> 在设计模式里很多模式都有体现单一职责，在函数式编程中函数柯里化对此也有体现，一个函数只干一件事

### 里氏替换原则LSP

> 所有引用基类的地方必须能透明地使用其子类的对象。说人话就是，子类可以扩展父类功能，但不能改变父类原有功能。

包含如下含义：

1. 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
1. 子类中可以增加自己特有的方法。
1. 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
1. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

这里就很容易让人误会，因为 OOP 希望子类能够多态，而里氏替换则不希望改变父类方法。但其实这两者完全不矛盾。另外值得一提的就是模版方法模式，看一下问题场景

**问题场景**  

假设超类 A 上有若干原型方法，其子类在继承其方法时嫌弃其原型方法过于简陋，又不希望暴露新的方法给调用者，
所以只能重写该方法，可是该方法被依赖了，而重写覆盖时没有实现原本功能，导致另一个方法调用出错

```js
class SuperA {
  counts = 0
  fn() {
    this.counts++
  }
  fn1() {
    console.log(this.counts)
  }
}

class A extends SuperA {
  fn() {
    console.log(123)
  }
}

const a = new A()
a.fn()
a.fn2()

// 方案1
class A extends SuperA {
  fn() {
    console.log(123)
    return super.fn()
  }
}
// 方案2 保证 fn 只调用了一个内部方法，重载保证调用那个方法
class A extends SuperA {
  fn() {
    return this._fn2()
  }
  _fn2() {
    // do something
    return this._fn()
  }
}
```

> 看起来方案1好像更哈

**解决方案**

1. 暴露给外部调用的方法最好不要被内部其他方法依赖，或者说暴露给外部的方法内部最好只调用另一个内部方法，使得其重写成本降到最低
1. 重载时可以进行参数预处理（更宽松的入参）
1. 重载时需要出参更严格，依赖该方法的调用者不会出错
1. 如果没必要的化还是加一个新方法吧

### 依赖倒置原则DIP

> 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

很抽象对吧？举个例子，我们会有各种插线板、插座，我们可以将它理解为高层模块，是一个负责接电的类。各个电子、电器厂商设计依赖这个高层模块的新型号产品（低层模块）。
我们再来看这句话。首先，厂商一般不会要求插线板厂商按照他们的设计改造插线板吧，这就是高层模块不应该依赖底层模块？
厂商会按照插线板的标准设计相应的插头，这就是类实现细节，它依赖了抽象（比如插头和电器、电子产品相连的头就是五花八门）
而插座设计的时候是不用考虑细节（比如两口和三口不能同时用这种脑残设计，插上后把开关怼了）

**问题场景**  

一个类在方法里可能使用不同类的实例的方法，而这些类的实例没有统一的接口时，就会发生意想不到的问题，
就如同一个老司机进入了一个不按常规生产的汽车，那么他是不会开车的

**解决方案**  

控制反转（IoC）：一种反转流、依赖和接口的方式（DIP的具体实现方式）。这是一个有点不太好理解和解释的概念，
通俗地说，就是应用程序本身不负责依赖对象的创建和维护，而是将它交给一个外部容器（比如Unity）来负责，
这样控制权就由应用程序转移到了外部IoC 容器，即控制权实现了所谓的反转。例如在类型A中需要使用类型B的实例，
而B 实例的创建并不由A 来负责，而是通过外部容器来创建。

依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。
也有很多博文里面说IOC也叫DI，其实根据博主的理解，DI应该是IOC的具体实现方式，比如我们如何实现控制反转，答案就是通过依赖注入去实现。

IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架），自动创建、维护依赖对象。

[t](https://blog.csdn.net/zhengzhb/article/list/2?t=1)

### 接口隔离原则ISP

>

**问题场景**
**解决方案**

### 最少知识原则

>

**问题场景**
**解决方案**

### 开放封闭原则

>

**问题场景**
**解决方案**

## 接口和面向接口编程
## 代码重构
