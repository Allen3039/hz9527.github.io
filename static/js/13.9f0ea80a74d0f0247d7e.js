webpackJsonp([13],{"3bWo":function(s,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var _={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("section",[a("h2",{attrs:{id:"重谈设计模式"}},[s._v("重谈设计模式")]),s._v(" "),a("blockquote",[a("p",[s._v("如果问我进入 js 世界对我影响最大的是什么，我一定会说设计模式。\n第一次看设计模式应该是 2016 年 9 月左右（JavaScript设计模式与开发实践-曾探）")])]),s._v(" "),a("h3",{attrs:{id:"前言"}},[s._v("前言")]),s._v(" "),a("blockquote",[a("p",[s._v("设计模式的定义是:在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。"),a("br"),s._v("\n设计模式一定程度增加了代码的复杂性，但毫无疑问它同样增加了代码的可维护性，或者说在一定区间里它会增加复杂度，但超过这个区间它的威力才能显现"),a("br"),s._v("\n设计模式是手段而不是目的"),a("br"),s._v("\nPeter Norvig 曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。")])]),s._v(" "),a("h3",{attrs:{id:"目录"}},[s._v("目录")]),s._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"}},[s._v("单例模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"}},[s._v("策略模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"}},[s._v("代理模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[s._v("迭代器模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"}},[s._v("发布订阅模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"}},[s._v("命令模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"}},[s._v("组合模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"}},[s._v("模版方法模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"}},[s._v("享元模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"}},[s._v("责任链模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E7%BB%88%E7%BB%93%E8%80%85%E6%A8%A1%E5%BC%8F"}},[s._v("终结者模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"}},[s._v("装饰者模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"}},[s._v("状态模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[s._v("适配器模式")])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99&%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7"}},[s._v("设计原则&编程技巧")])]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99SRP"}},[s._v("单一职责原则(Single Responsibility Principle)")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99LSP"}},[s._v("里氏替换原则")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99DIP"}},[s._v("依赖倒置原则DIP(Dependence Inversion Principle)")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99ISP"}},[s._v("接口隔离原则ISP(Interface Segregation Principle)")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99"}},[s._v("最少知识原则（迪米特原则）")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"}},[s._v("开放封闭原则")])])])]),s._v(" "),a("li",[a("p",[a("a",{attrs:{href:"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"}},[s._v("接口和面向接口编程")])])])]),s._v(" "),a("ol",[a("li",[s._v("OOP 继承、封装、多态、聚合")])]),s._v(" "),a("h3",{attrs:{id:"单例模式"}},[s._v("单例模式")]),s._v(" "),a("blockquote",[a("p",[s._v("单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。")])]),s._v(" "),a("p",[s._v("单例模式的使用场景十分多，从逻辑上来看有不可重复的数据，比如 全局缓存对象。从 UI 交互角度来看适用场景就更多了，比如 全局 toast 等等")]),s._v(" "),a("h4",{attrs:{id:"基本实现"}},[s._v("基本实现")]),s._v(" "),a("h3",{attrs:{id:"策略模式"}},[s._v("策略模式")]),s._v(" "),a("h3",{attrs:{id:"代理模式"}},[s._v("代理模式")]),s._v(" "),a("h3",{attrs:{id:"迭代器模式"}},[s._v("迭代器模式")]),s._v(" "),a("h3",{attrs:{id:"发布订阅模式"}},[s._v("发布订阅模式")]),s._v(" "),a("h3",{attrs:{id:"命令模式"}},[s._v("命令模式")]),s._v(" "),a("h3",{attrs:{id:"组合模式"}},[s._v("组合模式")]),s._v(" "),a("h3",{attrs:{id:"模版方法模式"}},[s._v("模版方法模式")]),s._v(" "),a("h3",{attrs:{id:"享元模式"}},[s._v("享元模式")]),s._v(" "),a("h3",{attrs:{id:"责任链模式"}},[s._v("责任链模式")]),s._v(" "),a("h3",{attrs:{id:"终结者模式"}},[s._v("终结者模式")]),s._v(" "),a("h3",{attrs:{id:"装饰者模式"}},[s._v("装饰者模式")]),s._v(" "),a("h3",{attrs:{id:"状态模式"}},[s._v("状态模式")]),s._v(" "),a("h3",{attrs:{id:"适配器模式"}},[s._v("适配器模式")]),s._v(" "),a("h3",{attrs:{id:"设计原则&编程技巧"}},[s._v("设计原则&编程技巧")]),s._v(" "),a("blockquote",[a("p",[s._v("面向对象编程通过封装不确定因素来使代码能被人理解;函数式编程通过尽量减少不确定因素来使代码能被人理解.\n没有最好的设计，只有最适合的设计，不同的场景这些原则划分的方式、定义的方式也不同，这也是为什么很容易出现过度设计，代码拆得太分散的原因。")])]),s._v(" "),a("h4",{attrs:{id:"单一职责原则SRP"}},[s._v("单一职责原则SRP")]),s._v(" "),a("blockquote",[a("p",[s._v("不要存在多于一个导致类变更的原因。简单点说，一个类，最好只负责一件事，只有一个引起它变化的原因。\n具体来说，当出现不确定因素时，我们尽量更改一处就可以了，因为根据单一职责，每个类尽量封装一处不确定因素")])]),s._v(" "),a("p",[a("strong",[s._v("问题场景")])]),s._v(" "),a("ul",[a("li",[s._v("类做了太多不该它管的事（正常人基本能避免）")]),s._v(" "),a("li",[s._v("职责扩散导致的问题，即由于不确定因素变更、增多使得内部耦合变得严重")])]),s._v(" "),a("blockquote",[a("p",[s._v("这个在我们编码时经常遇到，虽然我们都知道单一指责，听着也很简单。基本能遵守第一类场景，但不一定能很好遵守第二类场景。\n造成的原因是 随着需求的变动，\b发现一个方法内依赖了多个变化 职责（方法）间有耦合。")])]),s._v(" "),a("p",[s._v("举个例子：\n页面上有一个搜索框，然后有一个搜索和重置按钮。正常逻辑是点击搜索获取一下输入框的内容然后执行搜索，点击重置是清空输入框然后执行搜索")]),s._v(" "),a("pre",{pre:!0},[a("code",{attrs:{"v-pre":"",class:"language-js"}},[a("span",{attrs:{class:"hljs-class"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("InputComponent")]),s._v(" ")]),s._v("{\n  input(value) {\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search = value\n  }\n  search() {\n    get("),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search).then("),a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-params"}},[s._v("res")]),s._v(" =>")]),s._v(" render(res))\n  }\n  reset() {\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search = "),a("span",{attrs:{class:"hljs-literal"}},[s._v("null")]),s._v("\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search()\n  }\n}\n")])]),s._v(" "),a("p",[s._v("问题在于如果后续有多个搜索框呢？那么 reset 其实就和 input 耦合了，所以划分职责有问题。可以将 search 处理单独分出来")]),s._v(" "),a("p",[s._v("另一个常见的场景是函数入参的问题")]),s._v(" "),a("pre",{pre:!0},[a("code",{attrs:{"v-pre":"",class:"language-js"}},[a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("search")]),s._v("("),a("span",{attrs:{class:"hljs-params"}},[s._v("page, type")]),s._v(") ")]),s._v("{\n  "),a("span",{attrs:{class:"hljs-comment"}},[s._v("// ...")]),s._v("\n}\n"),a("span",{attrs:{class:"hljs-comment"}},[s._v("// 前置条件")]),s._v("\n"),a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("search")]),s._v("("),a("span",{attrs:{class:"hljs-params"}},[s._v("query")]),s._v(") ")]),s._v("{\n  "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" get(query)\n}\n"),a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("price")]),s._v("("),a("span",{attrs:{class:"hljs-params"}},[s._v("p")]),s._v(") ")]),s._v("{\n  "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),a("span",{attrs:{class:"hljs-function"}},[s._v("("),a("span",{attrs:{class:"hljs-params"}},[s._v("page, type")]),s._v(") =>")]),s._v(" {\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" query = {page, type, "),a("span",{attrs:{class:"hljs-attr"}},[s._v("price")]),s._v(": p}\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" search(query)\n  }\n}\nprice("),a("span",{attrs:{class:"hljs-number"}},[s._v("123")]),s._v(")("),a("span",{attrs:{class:"hljs-number"}},[s._v("10")]),s._v(", "),a("span",{attrs:{class:"hljs-string"}},[s._v("'1'")]),s._v(") "),a("span",{attrs:{class:"hljs-comment"}},[s._v("// 调用与原来一致")]),s._v("\n\n"),a("span",{attrs:{class:"hljs-comment"}},[s._v("// 后置条件")]),s._v("\n\n")])]),s._v(" "),a("p",[a("strong",[s._v("解决方案")])]),s._v(" "),a("p",[s._v("尽量让一个类、函数完成的工作只被一个因素改变，减少对外部依赖。单一职责很难的原因也是因为职责扩散问题，随着需求变动，\b可变因素增加。\n对于单一职责，没有最好的设计，只有最适合的设计")]),s._v(" "),a("blockquote",[a("p",[s._v("在设计模式里很多模式都有体现单一职责，在函数式编程中函数柯里化对此也有体现，一个函数只干一件事")])]),s._v(" "),a("h4",{attrs:{id:"里氏替换原则LSP"}},[s._v("里氏替换原则LSP")]),s._v(" "),a("blockquote",[a("p",[s._v("所有引用基类的地方必须能透明地使用其子类的对象。说人话就是，子类可以扩展父类功能，但不能改变父类原有功能。")])]),s._v(" "),a("p",[s._v("包含如下含义：")]),s._v(" "),a("ol",[a("li",[s._v("子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。")]),s._v(" "),a("li",[s._v("子类中可以增加自己特有的方法。")]),s._v(" "),a("li",[s._v("当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。")]),s._v(" "),a("li",[s._v("当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。")])]),s._v(" "),a("p",[s._v("这里就很容易让人误会，因为 OOP 希望子类能够多态，而里氏替换则不希望改变父类方法。但其实这两者完全不矛盾。另外值得一提的就是模版方法模式，看一下问题场景")]),s._v(" "),a("p",[a("strong",[s._v("问题场景")])]),s._v(" "),a("p",[s._v("假设超类 A 上有若干原型方法，其子类在继承其方法时嫌弃其原型方法过于简陋，又不希望暴露新的方法给调用者，\n所以只能重写该方法，可是该方法被依赖了，而重写覆盖时没有实现原本功能，导致另一个方法调用出错")]),s._v(" "),a("pre",{pre:!0},[a("code",{attrs:{"v-pre":"",class:"language-js"}},[a("span",{attrs:{class:"hljs-class"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  counts = "),a("span",{attrs:{class:"hljs-number"}},[s._v("0")]),s._v("\n  fn() {\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".counts++\n  }\n  fn1() {\n    "),a("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".counts)\n  }\n}\n\n"),a("span",{attrs:{class:"hljs-class"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("A")]),s._v(" "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("extends")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  fn() {\n    "),a("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),a("span",{attrs:{class:"hljs-number"}},[s._v("123")]),s._v(")\n  }\n}\n\n"),a("span",{attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" a = "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("new")]),s._v(" A()\na.fn()\na.fn2()\n\n"),a("span",{attrs:{class:"hljs-comment"}},[s._v("// 方案1")]),s._v("\n"),a("span",{attrs:{class:"hljs-class"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("A")]),s._v(" "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("extends")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  fn() {\n    "),a("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),a("span",{attrs:{class:"hljs-number"}},[s._v("123")]),s._v(")\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("super")]),s._v(".fn()\n  }\n}\n"),a("span",{attrs:{class:"hljs-comment"}},[s._v("// 方案2 保证 fn 只调用了一个内部方法，重载保证调用那个方法")]),s._v("\n"),a("span",{attrs:{class:"hljs-class"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("A")]),s._v(" "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("extends")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  fn() {\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v("._fn2()\n  }\n  _fn2() {\n    "),a("span",{attrs:{class:"hljs-comment"}},[s._v("// do something")]),s._v("\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v("._fn()\n  }\n}\n")])]),s._v(" "),a("blockquote",[a("p",[s._v("看起来方案1好像更哈")])]),s._v(" "),a("p",[a("strong",[s._v("解决方案")])]),s._v(" "),a("ol",[a("li",[s._v("暴露给外部调用的方法最好不要被内部其他方法依赖，或者说暴露给外部的方法内部最好只调用另一个内部方法，使得其重写成本降到最低")]),s._v(" "),a("li",[s._v("重载时可以进行参数预处理（更宽松的入参）")]),s._v(" "),a("li",[s._v("重载时需要出参更严格，依赖该方法的调用者不会出错")]),s._v(" "),a("li",[s._v("如果没必要的化还是加一个新方法吧")])]),s._v(" "),a("h4",{attrs:{id:"依赖倒置原则DIP"}},[s._v("依赖倒置原则DIP")]),s._v(" "),a("blockquote",[a("p",[s._v("高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。")])]),s._v(" "),a("p",[s._v("很抽象对吧？举个例子，我们会有各种插线板、插座，我们可以将它理解为高层模块，是一个负责接电的类。各个电子、电器厂商设计依赖这个高层模块的新型号产品（低层模块）。\n我们再来看这句话。首先，厂商一般不会要求插线板厂商按照他们的设计改造插线板吧，这就是高层模块不应该依赖底层模块？\n厂商会按照插线板的标准设计相应的插头，这就是类实现细节，它依赖了抽象（比如插头和电器、电子产品相连的头就是五花八门）\n而插座设计的时候是不用考虑细节（比如两口和三口不能同时用这种脑残设计，插上后把开关怼了）")]),s._v(" "),a("p",[a("strong",[s._v("问题场景")])]),s._v(" "),a("p",[s._v("一个类在方法里可能使用不同类的实例的方法，而这些类的实例没有统一的接口时，就会发生意想不到的问题，\n就如同一个老司机进入了一个不按常规生产的汽车，那么他是不会开车的")]),s._v(" "),a("p",[a("strong",[s._v("解决方案")])]),s._v(" "),a("p",[s._v("控制反转（IoC）：一种反转流、依赖和接口的方式（DIP的具体实现方式）。这是一个有点不太好理解和解释的概念，\n通俗地说，就是应用程序本身不负责依赖对象的创建和维护，而是将它交给一个外部容器（比如Unity）来负责，\n这样控制权就由应用程序转移到了外部IoC 容器，即控制权实现了所谓的反转。例如在类型A中需要使用类型B的实例，\n而B 实例的创建并不由A 来负责，而是通过外部容器来创建。")]),s._v(" "),a("p",[s._v("依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。\n也有很多博文里面说IOC也叫DI，其实根据博主的理解，DI应该是IOC的具体实现方式，比如我们如何实现控制反转，答案就是通过依赖注入去实现。")]),s._v(" "),a("p",[s._v("IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架），自动创建、维护依赖对象。")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/zhengzhb/article/list/2?t=1"}},[s._v("t")])]),s._v(" "),a("h4",{attrs:{id:"接口隔离原则ISP"}},[s._v("接口隔离原则ISP")]),s._v(" "),a("blockquote"),s._v(" "),a("p",[a("strong",[s._v("问题场景")]),s._v(" "),a("strong",[s._v("解决方案")])]),s._v(" "),a("h4",{attrs:{id:"最少知识原则"}},[s._v("最少知识原则")]),s._v(" "),a("blockquote"),s._v(" "),a("p",[a("strong",[s._v("问题场景")]),s._v(" "),a("strong",[s._v("解决方案")])]),s._v(" "),a("h4",{attrs:{id:"开放封闭原则"}},[s._v("开放封闭原则")]),s._v(" "),a("blockquote"),s._v(" "),a("p",[a("strong",[s._v("问题场景")]),s._v(" "),a("strong",[s._v("解决方案")])]),s._v(" "),a("h2",{attrs:{id:"接口和面向接口编程"}},[s._v("接口和面向接口编程")]),s._v(" "),a("h2",{attrs:{id:"代码重构"}},[s._v("代码重构")]),s._v(" "),a("pre",{pre:!0},[a("code",{attrs:{"v-pre":"",class:"language-js"}},[s._v("\nguide\n")])])])}]},v=a("VU/8")(null,_,!1,null,null,null);t.default=v.exports},yAqa:function(s,t,a){s.exports=a("3bWo")}});
//# sourceMappingURL=13.9f0ea80a74d0f0247d7e.js.map