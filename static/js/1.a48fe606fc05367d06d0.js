webpackJsonp([1],{"5aM9":function(s,t,e){s.exports=e("kfuu")},RBeL:function(s,t,e){s.exports=e.p+"static/img/eventLoop2.885e4e6.png"},kfuu:function(s,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a={render:function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("section",[e("h2",{attrs:{id:"事件循环"}},[s._v("事件循环")]),s._v(" "),e("div",{staticClass:"aside-menu"},[e("div",{directives:[{name:"toggle",rawName:"v-toggle"}],staticClass:"aside-menu-tit"},[s._v("menu")]),s._v(" "),s._m(0)]),e("b",{staticClass:"update-time"},[s._v(s._s(s._f("formatTime")(1542638016258)))]),e("b",{staticClass:"type"},[s._v("其他")]),s._v(" "),e("b",{staticClass:"kw"},[s._v("promise")]),s._v(" "),e("b",{staticClass:"kw"},[s._v("事件循环")]),s._v(" "),e("b",{staticClass:"kw"},[s._v("宏队列与微队列")]),s._v(" "),e("h3",{attrs:{id:"再看事件循环"}},[s._v("再看事件循环")]),s._v(" "),s._m(1),s._v(" "),s._m(2),s._v(" "),s._m(3),s._v(" "),e("p",[s._v("总之需要记住的是同一个 chunk 微队列先执行")]),s._v(" "),e("h3",{attrs:{id:"无阻塞"}},[s._v("无阻塞")]),s._v(" "),s._m(4),s._v(" "),e("p",[s._v("看代码")]),s._v(" "),s._m(5),s._v(" "),e("p",[s._v("答案是会 log 1。相信你对 无阻塞 有了认识了。意味着我们在主流程里 阻塞 了，会影响后续代码的运行，但不影响 事件循环")]),s._v(" "),s._m(6)])},staticRenderFns:[function(){var s=this.$createElement,t=this._self._c||s;return t("div",{staticClass:"aside-menu-con"},[t("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#再看事件循环"}},[this._v("再看事件循环")]),t("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#无阻塞"}},[this._v("无阻塞")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[this._v("首先上图"),t("br"),this._v(" "),t("img",{attrs:{src:e("RBeL"),width:"500px"}})])},function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("pre",{pre:!0},[e("code",{attrs:{"v-pre":"",class:"language-js"}},[s._v("\nsetTimeout("),e("span",{attrs:{class:"hljs-function"}},[e("span",{attrs:{class:"hljs-params"}},[s._v("()")]),s._v(" =>")]),s._v(" {\n  "),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),e("span",{attrs:{class:"hljs-number"}},[s._v("1")]),s._v(")\n})\n"),e("span",{attrs:{class:"hljs-built_in"}},[s._v("Promise")]),s._v(".resolve("),e("span",{attrs:{class:"hljs-number"}},[s._v("2")]),s._v(")\n  .then("),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log)\n")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("Job 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。\n每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue\n当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("我们经常说 js 是无阻塞 异步 IO")])])},function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("pre",{pre:!0},[e("code",{attrs:{"v-pre":"",class:"language-js"}},[s._v("setTimeout("),e("span",{attrs:{class:"hljs-function"}},[e("span",{attrs:{class:"hljs-params"}},[s._v("()")]),s._v(" =>")]),s._v(" {\n  "),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),e("span",{attrs:{class:"hljs-number"}},[s._v("1")]),s._v(")\n})\n\n"),e("span",{attrs:{class:"hljs-keyword"}},[s._v("throw")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("new")]),s._v(" "),e("span",{attrs:{class:"hljs-built_in"}},[s._v("Error")]),s._v("()\n"),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),e("span",{attrs:{class:"hljs-number"}},[s._v("2")]),s._v(")\n")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/30763470"}},[this._v("node timer")])])}]},n=e("VU/8")(null,a,!1,null,null,null);t.default=n.exports}});
//# sourceMappingURL=1.a48fe606fc05367d06d0.js.map