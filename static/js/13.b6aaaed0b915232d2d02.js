webpackJsonp([13],{"3bWo":function(s,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a={render:function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("section",[e("div",{staticClass:"aside-menu"},[e("div",{directives:[{name:"toggle",rawName:"v-toggle"}],staticClass:"aside-menu-tit"}),s._m(0)]),e("h2",{attrs:{id:"%E9%87%8D%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"}},[s._v("重谈设计模式")]),s._v(" "),s._m(1),s._v(" "),e("h3",{attrs:{id:"%E5%89%8D%E8%A8%80-1"}},[s._v("前言")]),s._v(" "),s._m(2),s._v(" "),e("h3",{attrs:{id:"%E7%9B%AE%E5%BD%95-1"}},[s._v("目录")]),s._v(" "),s._m(3),s._v(" "),s._m(4),s._v(" "),e("h3",{attrs:{id:"%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1"}},[s._v("单例模式")]),s._v(" "),s._m(5),s._v(" "),e("p",[s._v("单例模式的使用场景十分多，从逻辑上来看有不可重复的数据，比如 全局缓存对象。从 UI 交互角度来看适用场景就更多了，比如 全局 toast 等等")]),s._v(" "),e("h4",{attrs:{id:"%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0-1"}},[s._v("基本实现")]),s._v(" "),e("h3",{attrs:{id:"%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1"}},[s._v("策略模式")]),s._v(" "),e("h3",{attrs:{id:"%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1"}},[s._v("代理模式")]),s._v(" "),e("h3",{attrs:{id:"%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-1"}},[s._v("迭代器模式")]),s._v(" "),e("h3",{attrs:{id:"%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-1"}},[s._v("发布订阅模式")]),s._v(" "),e("h3",{attrs:{id:"%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-1"}},[s._v("命令模式")]),s._v(" "),e("h3",{attrs:{id:"%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-1"}},[s._v("组合模式")]),s._v(" "),e("h3",{attrs:{id:"%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-1"}},[s._v("模版方法模式")]),s._v(" "),e("h3",{attrs:{id:"%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-1"}},[s._v("享元模式")]),s._v(" "),e("h3",{attrs:{id:"%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-1"}},[s._v("责任链模式")]),s._v(" "),e("h3",{attrs:{id:"%E7%BB%88%E7%BB%93%E8%80%85%E6%A8%A1%E5%BC%8F-1"}},[s._v("终结者模式")]),s._v(" "),e("h3",{attrs:{id:"%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-1"}},[s._v("装饰者模式")]),s._v(" "),e("h3",{attrs:{id:"%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-1"}},[s._v("状态模式")]),s._v(" "),e("h3",{attrs:{id:"%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-1"}},[s._v("适配器模式")]),s._v(" "),e("h3",{attrs:{id:"%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%26%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-1"}},[s._v("设计原则&编程技巧")]),s._v(" "),s._m(6),s._v(" "),e("h4",{attrs:{id:"%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp-1"}},[s._v("单一职责原则SRP")]),s._v(" "),s._m(7),s._v(" "),s._m(8),s._v(" "),s._m(9),s._v(" "),s._m(10),s._v(" "),e("p",[s._v("举个例子：\n页面上有一个搜索框，然后有一个搜索和重置按钮。正常逻辑是点击搜索获取一下输入框的内容然后执行搜索，点击重置是清空输入框然后执行搜索")]),s._v(" "),s._m(11),s._v(" "),e("p",[s._v("问题在于如果后续有多个搜索框呢？那么 reset 其实就和 input 耦合了，所以划分职责有问题。可以将 search 处理单独分出来")]),s._v(" "),e("p",[s._v("另一个常见的场景是函数入参的问题")]),s._v(" "),s._m(12),s._v(" "),s._m(13),s._v(" "),e("p",[s._v("尽量让一个类、函数完成的工作只被一个因素改变，减少对外部依赖。单一职责很难的原因也是因为职责扩散问题，随着需求变动，\b可变因素增加。\n对于单一职责，没有最好的设计，只有最适合的设计")]),s._v(" "),s._m(14),s._v(" "),e("h4",{attrs:{id:"%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp-1"}},[s._v("里氏替换原则LSP")]),s._v(" "),s._m(15),s._v(" "),e("p",[s._v("包含如下含义：")]),s._v(" "),s._m(16),s._v(" "),e("p",[s._v("这里就很容易让人误会，因为 OOP 希望子类能够多态，而里氏替换则不希望改变父类方法。但其实这两者完全不矛盾。另外值得一提的就是模版方法模式，看一下问题场景")]),s._v(" "),s._m(17),s._v(" "),e("p",[s._v("假设超类 A 上有若干原型方法，其子类在继承其方法时嫌弃其原型方法过于简陋，又不希望暴露新的方法给调用者，\n所以只能重写该方法，可是该方法被依赖了，而重写覆盖时没有实现原本功能，导致另一个方法调用出错")]),s._v(" "),s._m(18),s._v(" "),s._m(19),s._v(" "),s._m(20),s._v(" "),s._m(21),s._v(" "),e("h4",{attrs:{id:"%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99dip-1"}},[s._v("依赖倒置原则DIP")]),s._v(" "),s._m(22),s._v(" "),e("p",[s._v("很抽象对吧？举个例子，我们会有各种插线板、插座，我们可以将它理解为高层模块，是一个负责接电的类。各个电子、电器厂商设计依赖这个高层模块的新型号产品（低层模块）。\n我们再来看这句话。首先，厂商一般不会要求插线板厂商按照他们的设计改造插线板吧，这就是高层模块不应该依赖底层模块？\n厂商会按照插线板的标准设计相应的插头，这就是类实现细节，它依赖了抽象（比如插头和电器、电子产品相连的头就是五花八门）\n而插座设计的时候是不用考虑细节（比如两口和三口不能同时用这种脑残设计，插上后把开关怼了）")]),s._v(" "),s._m(23),s._v(" "),e("p",[s._v("一个类在方法里可能使用不同类的实例的方法，而这些类的实例没有统一的接口时，就会发生意想不到的问题，\n就如同一个老司机进入了一个不按常规生产的汽车，那么他是不会开车的")]),s._v(" "),s._m(24),s._v(" "),e("p",[s._v("控制反转（IoC）：一种反转流、依赖和接口的方式（DIP的具体实现方式）。这是一个有点不太好理解和解释的概念，\n通俗地说，就是应用程序本身不负责依赖对象的创建和维护，而是将它交给一个外部容器（比如Unity）来负责，\n这样控制权就由应用程序转移到了外部IoC 容器，即控制权实现了所谓的反转。例如在类型A中需要使用类型B的实例，\n而B 实例的创建并不由A 来负责，而是通过外部容器来创建。")]),s._v(" "),e("p",[s._v("依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。\n也有很多博文里面说IOC也叫DI，其实根据博主的理解，DI应该是IOC的具体实现方式，比如我们如何实现控制反转，答案就是通过依赖注入去实现。")]),s._v(" "),e("p",[s._v("IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架），自动创建、维护依赖对象。")]),s._v(" "),s._m(25),s._v(" "),e("h4",{attrs:{id:"%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99isp-1"}},[s._v("接口隔离原则ISP")]),s._v(" "),e("blockquote"),s._v(" "),s._m(26),s._v(" "),e("h4",{attrs:{id:"%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99-1"}},[s._v("最少知识原则")]),s._v(" "),e("blockquote"),s._v(" "),s._m(27),s._v(" "),e("h4",{attrs:{id:"%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99-1"}},[s._v("开放封闭原则")]),s._v(" "),e("blockquote"),s._v(" "),s._m(28),s._v(" "),e("h2",{attrs:{id:"%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B-1"}},[s._v("接口和面向接口编程")]),s._v(" "),e("h2",{attrs:{id:"%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84-1"}},[s._v("代码重构")]),s._v(" "),s._m(29)])},staticRenderFns:[function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("div",{staticClass:"aside-menu-con"},[e("a",{staticClass:"level-2 aside-menu-item",attrs:{href:"#%E9%87%8D%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"}},[s._v("重谈设计模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E5%89%8D%E8%A8%80-1"}},[s._v("前言")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E7%9B%AE%E5%BD%95-1"}},[s._v("目录")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1"}},[s._v("单例模式")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0-1"}},[s._v("基本实现")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1"}},[s._v("策略模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1"}},[s._v("代理模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-1"}},[s._v("迭代器模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-1"}},[s._v("发布订阅模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-1"}},[s._v("命令模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-1"}},[s._v("组合模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-1"}},[s._v("模版方法模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-1"}},[s._v("享元模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-1"}},[s._v("责任链模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E7%BB%88%E7%BB%93%E8%80%85%E6%A8%A1%E5%BC%8F-1"}},[s._v("终结者模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-1"}},[s._v("装饰者模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-1"}},[s._v("状态模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-1"}},[s._v("适配器模式")]),e("a",{staticClass:"level-3 aside-menu-item",attrs:{href:"#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%26%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-1"}},[s._v("设计原则&编程技巧")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp-1"}},[s._v("单一职责原则SRP")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp-1"}},[s._v("里氏替换原则LSP")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99dip-1"}},[s._v("依赖倒置原则DIP")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99isp-1"}},[s._v("接口隔离原则ISP")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99-1"}},[s._v("最少知识原则")]),e("a",{staticClass:"level-4 aside-menu-item",attrs:{href:"#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99-1"}},[s._v("开放封闭原则")]),e("a",{staticClass:"level-2 aside-menu-item",attrs:{href:"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B-1"}},[s._v("接口和面向接口编程")]),e("a",{staticClass:"level-2 aside-menu-item",attrs:{href:"#%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84-1"}},[s._v("代码重构")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("如果问我进入 js 世界对我影响最大的是什么，我一定会说设计模式。\n第一次看设计模式应该是 2016 年 9 月左右（JavaScript设计模式与开发实践-曾探）")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("设计模式的定义是:在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。"),t("br"),this._v("\n设计模式一定程度增加了代码的复杂性，但毫无疑问它同样增加了代码的可维护性，或者说在一定区间里它会增加复杂度，但超过这个区间它的威力才能显现"),t("br"),this._v("\n设计模式是手段而不是目的"),t("br"),this._v("\nPeter Norvig 曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。")])])},function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ul",[e("li",[e("p",[e("a",{attrs:{href:"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"}},[s._v("单例模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"}},[s._v("策略模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"}},[s._v("代理模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[s._v("迭代器模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"}},[s._v("发布订阅模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"}},[s._v("命令模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"}},[s._v("组合模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"}},[s._v("模版方法模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"}},[s._v("享元模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"}},[s._v("责任链模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E7%BB%88%E7%BB%93%E8%80%85%E6%A8%A1%E5%BC%8F"}},[s._v("终结者模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"}},[s._v("装饰者模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"}},[s._v("状态模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[s._v("适配器模式")])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99&%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7"}},[s._v("设计原则&编程技巧")])]),s._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99SRP"}},[s._v("单一职责原则(Single Responsibility Principle)")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99LSP"}},[s._v("里氏替换原则")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99DIP"}},[s._v("依赖倒置原则DIP(Dependence Inversion Principle)")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99ISP"}},[s._v("接口隔离原则ISP(Interface Segregation Principle)")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99"}},[s._v("最少知识原则（迪米特原则）")])]),s._v(" "),e("li",[e("a",{attrs:{href:"#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"}},[s._v("开放封闭原则")])])])]),s._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"}},[s._v("接口和面向接口编程")])])])])},function(){var s=this.$createElement,t=this._self._c||s;return t("ol",[t("li",[this._v("OOP 继承、封装、多态、聚合")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("面向对象编程通过封装不确定因素来使代码能被人理解;函数式编程通过尽量减少不确定因素来使代码能被人理解.\n没有最好的设计，只有最适合的设计，不同的场景这些原则划分的方式、定义的方式也不同，这也是为什么很容易出现过度设计，代码拆得太分散的原因。")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("不要存在多于一个导致类变更的原因。简单点说，一个类，最好只负责一件事，只有一个引起它变化的原因。\n具体来说，当出现不确定因素时，我们尽量更改一处就可以了，因为根据单一职责，每个类尽量封装一处不确定因素")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("问题场景")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("ul",[t("li",[this._v("类做了太多不该它管的事（正常人基本能避免）")]),this._v(" "),t("li",[this._v("职责扩散导致的问题，即由于不确定因素变更、增多使得内部耦合变得严重")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("这个在我们编码时经常遇到，虽然我们都知道单一指责，听着也很简单。基本能遵守第一类场景，但不一定能很好遵守第二类场景。\n造成的原因是 随着需求的变动，\b发现一个方法内依赖了多个变化 职责（方法）间有耦合。")])])},function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("pre",{pre:!0},[e("code",{attrs:{"v-pre":"",class:"language-js"}},[e("span",{attrs:{class:"hljs-class"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("InputComponent")]),s._v(" ")]),s._v("{\n  input(value) {\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search = value\n  }\n  search() {\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("get")]),s._v("(this.search).then(res => render(res))\n  }\n  reset() {\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search = "),e("span",{attrs:{class:"hljs-literal"}},[s._v("null")]),s._v("\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".search()\n  }\n}\n")])])},function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("pre",{pre:!0},[e("code",{attrs:{"v-pre":"",class:"language-js"}},[e("span",{attrs:{class:"hljs-function"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("search")]),s._v("("),e("span",{attrs:{class:"hljs-params"}},[s._v("page, type")]),s._v(") ")]),s._v("{\n  "),e("span",{attrs:{class:"hljs-comment"}},[s._v("// ...")]),s._v("\n}\n"),e("span",{attrs:{class:"hljs-comment"}},[s._v("// 前置条件")]),s._v("\n"),e("span",{attrs:{class:"hljs-function"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("search")]),s._v("("),e("span",{attrs:{class:"hljs-params"}},[s._v("query")]),s._v(") ")]),s._v("{\n  "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("get")]),s._v("(query)\n}\nfunction price(p) {\n  "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),e("span",{attrs:{class:"hljs-function"}},[s._v("("),e("span",{attrs:{class:"hljs-params"}},[s._v("page, type")]),s._v(") =>")]),s._v(" {\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" query = {page, type, "),e("span",{attrs:{class:"hljs-attr"}},[s._v("price")]),s._v(": p}\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" search(query)\n  }\n}\nprice("),e("span",{attrs:{class:"hljs-number"}},[s._v("123")]),s._v(")("),e("span",{attrs:{class:"hljs-number"}},[s._v("10")]),s._v(", "),e("span",{attrs:{class:"hljs-string"}},[s._v("'1'")]),s._v(") "),e("span",{attrs:{class:"hljs-comment"}},[s._v("// 调用与原来一致")]),s._v("\n\n"),e("span",{attrs:{class:"hljs-comment"}},[s._v("// 后置条件")]),s._v("\n\n")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("解决方案")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("在设计模式里很多模式都有体现单一职责，在函数式编程中函数柯里化对此也有体现，一个函数只干一件事")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("所有引用基类的地方必须能透明地使用其子类的对象。说人话就是，子类可以扩展父类功能，但不能改变父类原有功能。")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("ol",[t("li",[this._v("子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。")]),this._v(" "),t("li",[this._v("子类中可以增加自己特有的方法。")]),this._v(" "),t("li",[this._v("当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。")]),this._v(" "),t("li",[this._v("当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("问题场景")])])},function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("pre",{pre:!0},[e("code",{attrs:{"v-pre":"",class:"language-js"}},[e("span",{attrs:{class:"hljs-class"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  counts = "),e("span",{attrs:{class:"hljs-number"}},[s._v("0")]),s._v("\n  fn() {\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".counts++\n  }\n  fn1() {\n    "),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".counts)\n  }\n}\n\n"),e("span",{attrs:{class:"hljs-class"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("A")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("extends")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  fn() {\n    "),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),e("span",{attrs:{class:"hljs-number"}},[s._v("123")]),s._v(")\n  }\n}\n\n"),e("span",{attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" a = "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("new")]),s._v(" A()\na.fn()\na.fn2()\n\n"),e("span",{attrs:{class:"hljs-comment"}},[s._v("// 方案1")]),s._v("\n"),e("span",{attrs:{class:"hljs-class"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("A")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("extends")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  fn() {\n    "),e("span",{attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log("),e("span",{attrs:{class:"hljs-number"}},[s._v("123")]),s._v(")\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("super")]),s._v(".fn()\n  }\n}\n"),e("span",{attrs:{class:"hljs-comment"}},[s._v("// 方案2 保证 fn 只调用了一个内部方法，重载保证调用那个方法")]),s._v("\n"),e("span",{attrs:{class:"hljs-class"}},[e("span",{attrs:{class:"hljs-keyword"}},[s._v("class")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("A")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("extends")]),s._v(" "),e("span",{attrs:{class:"hljs-title"}},[s._v("SuperA")]),s._v(" ")]),s._v("{\n  fn() {\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v("._fn2()\n  }\n  _fn2() {\n    "),e("span",{attrs:{class:"hljs-comment"}},[s._v("// do something")]),s._v("\n    "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),e("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v("._fn()\n  }\n}\n")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("看起来方案1好像更哈")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("解决方案")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("ol",[t("li",[this._v("暴露给外部调用的方法最好不要被内部其他方法依赖，或者说暴露给外部的方法内部最好只调用另一个内部方法，使得其重写成本降到最低")]),this._v(" "),t("li",[this._v("重载时可以进行参数预处理（更宽松的入参）")]),this._v(" "),t("li",[this._v("重载时需要出参更严格，依赖该方法的调用者不会出错")]),this._v(" "),t("li",[this._v("如果没必要的化还是加一个新方法吧")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("blockquote",[t("p",[this._v("高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("问题场景")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("解决方案")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("a",{attrs:{href:"https://blog.csdn.net/zhengzhb/article/list/2?t=1"}},[this._v("t")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("问题场景")]),this._v(" "),t("strong",[this._v("解决方案")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("问题场景")]),this._v(" "),t("strong",[this._v("解决方案")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("strong",[this._v("问题场景")]),this._v(" "),t("strong",[this._v("解决方案")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":"",class:"language-js"}},[this._v("\nguide\n")])])}]},E=e("VU/8")(null,a,!1,null,null,null);t.default=E.exports},yAqa:function(s,t,e){s.exports=e("3bWo")}});
//# sourceMappingURL=13.b6aaaed0b915232d2d02.js.map