webpackJsonp([3],{JpAa:function(s,t,a){s.exports=a("UR5B")},UR5B:function(s,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var e={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("section",[a("h2",{attrs:{id:"设计一个mvvm框架"}},[s._v("设计一个mvvm框架")]),s._v(" "),a("blockquote",[a("p",[s._v("我们知道 vue 是通过 Watcher 类实现数据更改的监听，从而实现双向数据绑定，React 则是 通过 setData 来触发 render，但是刚刚看了一篇博客，醍醐灌顶\n"),a("a",{attrs:{href:"https://segmentfault.com/a/1190000013040438"}},[s._v("Dan reply Michel")]),s._v(" "),a("a",{attrs:{href:"https://github.com/facebook/react/issues/11527#issuecomment-360199710"}},[s._v("git issue")]),s._v("\nDan 说会考虑调用者来决定是否同步 （setData 源码注释  There is no guarantee that "),a("code",{pre:!0},[s._v("this.state")]),s._v(" will be immediately updated, so accessing "),a("code",{pre:!0},[s._v("this.state")]),s._v(" after calling this method may return the old value.）。这里实在是太精妙了")])]),s._v(" "),a("p",[s._v("那么灵感是什么呢？")]),s._v(" "),a("ol",[a("li",[s._v("由于组件化，我们在写组件是基本都是通过类或者 Options实现")]),s._v(" "),a("li",[s._v("提供生命周期给开发者使用")])]),s._v(" "),a("p",[s._v("所以有一个现象就是，我们基本只能定义一套模版，通过响应事件来完成视图的更新，这么一说感觉还挺像 CycleJs 了"),a("br"),s._v("\n这也意味着我们更新视图只能通过方法了，那么我们是不是可以覆盖这个方法呢？假设我们实现了一套类似 Vue 的框架")]),s._v(" "),a("pre",{pre:!0},[a("code",{attrs:{"v-pre":"",class:"language-js"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("new")]),s._v(" App(Options)\n\n"),a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{attrs:{class:"hljs-title"}},[s._v("App")]),s._v("("),a("span",{attrs:{class:"hljs-params"}},[s._v("opt")]),s._v(") ")]),s._v("{\n  "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".stack = "),a("span",{attrs:{class:"hljs-number"}},[s._v("0")]),s._v("\n  "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("for")]),s._v(" ("),a("span",{attrs:{class:"hljs-keyword"}},[s._v("let")]),s._v(" key "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("in")]),s._v(" opt) {\n    "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" ("),a("span",{attrs:{class:"hljs-keyword"}},[s._v("typeof")]),s._v(" opt[key] === "),a("span",{attrs:{class:"hljs-string"}},[s._v("'function'")]),s._v(") {\n      "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v("[key] = "),a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v("("),a("span",{attrs:{class:"hljs-params"}}),s._v(") ")]),s._v("{\n        "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".stack++\n        opt[key].apply("),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(", "),a("span",{attrs:{class:"hljs-built_in"}},[s._v("arguments")]),s._v(")\n        "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".stack--\n        "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".stack === "),a("span",{attrs:{class:"hljs-number"}},[s._v("0")]),s._v(" && "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".render()\n      }\n    } "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("else")]),s._v(" {\n      "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v("[key] = opt[key]\n    }\n  }\n}\n\nApp.prototype.render = "),a("span",{attrs:{class:"hljs-function"}},[a("span",{attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v("("),a("span",{attrs:{class:"hljs-params"}}),s._v(") ")]),s._v("{\n  "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" ("),a("span",{attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".isNeedRender()) "),a("span",{attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v("\n  "),a("span",{attrs:{class:"hljs-comment"}},[s._v("// render")]),s._v("\n}\n")])])])}]},n=a("VU/8")(null,e,!1,null,null,null);t.default=n.exports}});
//# sourceMappingURL=3.a6e39c580462da47c3fb.js.map